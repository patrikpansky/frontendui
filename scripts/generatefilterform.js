#!/usr/bin/env node
const fs = require("fs");
const path = require("path");

// Operátory podle typu
const FILTER_OPERATORS = {
    String:   ["_eq", "_neq", "_like", "_ilike", "_is_null"],
    Int:      ["_eq", "_neq", "_gt", "_lt", "_gte", "_lte", "_in", "_nin", "_is_null"],
    Float:    ["_eq", "_neq", "_gt", "_lt", "_gte", "_lte", "_in", "_nin", "_is_null"],
    Boolean:  ["_eq", "_neq", "_is_null"],
    UUID:     ["_eq", "_neq", "_in", "_nin", "_is_null"],
    Date:     ["_eq", "_neq", "_gt", "_lt", "_gte", "_lte", "_is_null"],
    DateTime: ["_eq", "_neq", "_gt", "_lt", "_gte", "_lte", "_is_null"],
    Timestamp:["_eq", "_neq", "_gt", "_lt", "_gte", "_lte", "_is_null"],
    BigInt:   ["_eq", "_neq", "_gt", "_lt", "_gte", "_lte", "_in", "_nin", "_is_null"],
    // Další podle potřeby...
};

/**
 * Vrátí mapu {fieldName: scalarType} pro input typ (např. AdmissionInputFilter).
 * Nevrací _and/_or ani relation filtry.
 */
function getScalarFieldTypes(ast, inputTypeName) {
    const inputType = (ast.definitions || []).find(
        d => d.kind === "InputObjectTypeDefinition" && d.name.value === inputTypeName
    );
    if (!inputType) throw new Error(`Input type ${inputTypeName} not found`);
    const fieldTypes = {};
    for (const f of inputType.fields) {
        if (!f.name.value.startsWith("_") && f.type.kind === "NamedType") {
            fieldTypes[f.name.value] = f.type.name.value;
        }
    }
    return fieldTypes;
}

function findComparisonExpType(ast, fieldTypeName) {
    const tryNames = [`${fieldTypeName}ComparisonExp`, `${fieldTypeName}_comparison_exp`];
    for (const name of tryNames) {
        const def = (ast.definitions || []).find(
            d => d.kind === "InputObjectTypeDefinition" && d.name.value === name
        );
        if (def) return def;
    }
    return null;
}

// Vygeneruj mapu operátorů podle fieldu
function generateFilterOperatorsByType(ast, fieldTypes) {
    const filterOps = {};
    for (const [field, scalarType] of Object.entries(fieldTypes)) {
        const compExpDef = findComparisonExpType(ast, scalarType);
        if (compExpDef) {
            filterOps[field] = compExpDef.fields.map(f => f.name.value);
        } else if (scalarType === "Boolean") {
            filterOps[field] = ["_eq", "_neq", "_is_null"];
        } else {
            filterOps[field] = ["_eq", "_neq", "_is_null"];
        }
    }
    return filterOps;
}

function getScalarFieldNames(fieldTypes) {
    return Object.keys(fieldTypes);
}

/**
 * Vrací input typ filtru pro dotaz vracející List[Object!]! daného typu.
 * 
 * @param {object} ast  AST dokument (SDL)
 * @param {string} objectTypeName  Název objektu (např. "AdmissionGQLModel")
 * @returns {string} Název input filtru (např. "AdmissionInputFilter")
 */
function findFilterType(ast, objectTypeName) {
    // Najdi Query typ
    const queryDef = (ast.definitions || []).find(
        d => d.kind === "ObjectTypeDefinition" && d.name.value === "Query"
    );
    if (!queryDef) throw new Error("No Query type found in SDL!");

    // Najdi field v Query, který vrací List[objectTypeName!]
    const listField = (queryDef.fields || []).find(field => {
        // Unwrap do ListType (musí být přímo nebo pod NonNullType)
        let t = field.type;
        while (t.kind === "NonNullType") t = t.type;
        if (t.kind !== "ListType") return false; // musí to být ListType
        // ListType -> type je NonNullType, uvnitř NamedType
        let listOf = t.type;
        while (listOf.kind === "NonNullType") listOf = listOf.type;
        // Musí být NamedType a mít správné jméno
        return listOf.kind === "NamedType" && listOf.name.value === objectTypeName;
    });
    if (!listField) throw new Error(`No Query field found returning List[${objectTypeName}!]!`);

    // Najdi argument where (input type)
    const whereArg = (listField.arguments || []).find(
        arg =>
            arg.name.value === "where" &&
            (arg.type.kind === "NamedType" || arg.type.type?.kind === "NamedType")
    );
    if (!whereArg) throw new Error(`Query field ${listField.name.value} has no "where" argument`);
    return whereArg.type.kind === "NamedType"
        ? whereArg.type.name.value
        : whereArg.type.type.name.value;
}

/**
 * Generuje React komponentu filtru s podporou operátorů a mazání podmínek.
 */
function generateFilterFormComponent(inputTypeName, fieldTypes, scalarFields, filterOperatorsByType, exportComponentName) {
    // Build fieldTypes map string
    const fieldTypesStr = JSON.stringify(fieldTypes, null, 4);
    const scalarArrStr = JSON.stringify(scalarFields);
    const filterOperatorsStr = JSON.stringify(filterOperatorsByType, null, 4);
    return `/**
 * Generated filter form for ${inputTypeName}, Bootstrap styl, single field selection, logická pole.
 * Generated by generate-hasura-filter-form.js
 */
import { SimpleCardCapsule } from "@hrbolek/uoisfrontend-shared";
import React from "react";
import { Col, Row } from "react-bootstrap";

const logicalFields = ['_and', '_or'];
const fieldTypes = ${fieldTypesStr};
const filterOperatorsByType = ${filterOperatorsStr};

function getHtmlInputType(scalarType) {
    switch (scalarType) {
        case "String": return "text";
        case "Int": case "BigInt": return "number";
        case "Float": case "Decimal": return "number";
        case "Boolean": return "checkbox";
        case "Date": return "date";
        case "Time": return "time";
        case "DateTime": case "Timestamp": return "datetime-local";
        default: return "text";
    }
}
function getFieldScalarType(fieldName) {
    return fieldTypes[fieldName] || "String";
}

/**
 * @param {object} props
 * @param {object} props.value  Aktuální hodnota filtru (where objekt)
 * @param {function} props.onChange  Callback onChange(newValue)
 * @param {string|null} [props.parentLogical]  Parent logical (pokud je uvnitř _and/_or)
 * @param {function} [props.onRemove] Callback na odstranění podmínky (volitelné, použije se pro zanoření)
 */
export function ${exportComponentName}({ value = {}, onChange, parentLogical = null, onRemove }) {
    const activeLogical = Object.keys(value).find(k => logicalFields.includes(k));
    const isLogic = !!activeLogical;
    const scalars = ${scalarArrStr};
    const logical = logicalFields.filter(x => x !== parentLogical);

    // Pro scalar filtr
    const selectedField = !isLogic ? Object.keys(value).find(k => !k.startsWith("_")) || "" : "";
    const operatorList = selectedField ? (filterOperatorsByType[getFieldScalarType(selectedField)] || ["_eq"]) : ["_eq"];
    const selectedOperator = selectedField ? (Object.keys(value[selectedField] || {})[0] || operatorList[0]) : operatorList[0];
    const [operand, setOperand] = React.useState(selectedField ? value[selectedField]?.[selectedOperator] ?? "" : "");
    const [operator, setOperator] = React.useState(selectedOperator);

    React.useEffect(() => {
        if (selectedField) {
            setOperator(selectedOperator);
            setOperand(value[selectedField]?.[selectedOperator] ?? "");
        }
    }, [value, selectedField, selectedOperator]);

    function handleFieldChange(e) {
        const f = e.target.value;
        setOperand(""); setOperator("_eq");
        onChange({ [f]: { "_eq": "" } });
    }
    function handleOperatorChange(e) {
        setOperator(e.target.value);
        onChange({ [selectedField]: { [e.target.value]: operand } });
    }
    function handleOperandChange(e) {
        let val = e.target.value;
        if (e.target.type === "checkbox") val = e.target.checked;
        setOperand(val);
        onChange({ [selectedField]: { [operator]: val } });
    }
    function handleAddLogical(logicKey) {
        onChange({ [logicKey]: [{}] });
    }
    function handleLogicChange(idx, v) {
        const arr = [...(value[activeLogical] || [])];
        arr[idx] = v;
        onChange({ [activeLogical]: arr });
    }
    function handleRemove() {
        if (onRemove) onRemove();
    }
    function handleRemoveLogic(idx) {
        const arr = [...(value[activeLogical] || [])];
        arr.splice(idx, 1);
        onChange({ [activeLogical]: arr });
    }

    return (
        <div>
            <div className="mb-3 d-flex gap-2">
                {/* Logická tlačítka na začátku */}
                {!isLogic && logical.length > 0 && (
                    <div className="mb-3 d-flex gap-2">
                        {logical.map(f => (
                            <button key={f} type="button"
                                className="btn btn-outline-primary form-control"
                                onClick={() => handleAddLogical(f)}
                            >{f.toUpperCase()}</button>
                        ))}
                    </div>
                )}
                {/* Výběr field+operátor+hodnota */}
                {!isLogic && !selectedField && (
                    <SimpleCardCapsule title={"Operátor/field"}>
                        <select className="form-select" value={selectedField} onChange={handleFieldChange}>
                            <option value="">Vyber operátor…</option>
                            {scalars.map(f => <option key={f} value={f}>{f}</option>)}
                        </select>
                    </SimpleCardCapsule>
                )}
                {!isLogic && selectedField && (() => {
                    const scalarType = getFieldScalarType(selectedField);
                    const inputType = getHtmlInputType(scalarType);
                    const operators = filterOperatorsByType[scalarType] || ["_eq"];
                    return (
                        <SimpleCardCapsule title={selectedField.toUpperCase()}>
                            <Row>
                                <Col>
                                    <select className="form-select" value={selectedField} onChange={handleFieldChange}>
                                        <option value="">Vyber field…</option>
                                        {scalars.map(f => <option key={f} value={f}>{f}</option>)}
                                    </select>
                                </Col>
                                <Col>
                                    <select className="form-select" value={operator} onChange={handleOperatorChange}>
                                        {operators.map(op => <option key={op} value={op}>{op}</option>)}
                                    </select>
                                </Col>
                                <Col>
                                    {operator === "_is_null" ? (
                                        <select className="form-select" value={operand ? "true" : "false"} onChange={e => handleOperandChange({target: {value: e.target.value === "true"}})}>
                                            <option value="false">Není null</option>
                                            <option value="true">Je null</option>
                                        </select>
                                    ) : (
                                        <input
                                            className="form-control"
                                            type={inputType}
                                            value={inputType === "checkbox" ? undefined : operand}
                                            checked={inputType === "checkbox" ? operand || false : undefined}
                                            onChange={handleOperandChange}
                                            placeholder={"Zadej hodnotu"}
                                        />
                                    )}
                                </Col>
                                <Col xs="auto">
                                    {onRemove && (
                                        <button className="btn btn-outline-danger" type="button" onClick={handleRemove}>✕</button>
                                    )}
                                </Col>
                            </Row>
                        </SimpleCardCapsule>
                    );
                })()}
                {/* Logický blok */}
                {isLogic && (
                    <SimpleCardCapsule title={activeLogical.toUpperCase()}>
                        {(value[activeLogical] || []).map((item, idx) => (
                            <${exportComponentName}
                                key={idx}
                                value={item}
                                onChange={v => handleLogicChange(idx, v)}
                                parentLogical={activeLogical}
                                onRemove={() => handleRemoveLogic(idx)}
                            />
                        ))}
                        <button
                            className="btn btn-outline-primary btn-sm mt-1"
                            type="button"
                            onClick={() => onChange({ ...value, [activeLogical]: [...(value[activeLogical] || []), {}] })}
                        >
                            Přidat podmínku
                        </button>
                        {!!onRemove && (
                            <button className="btn btn-outline-danger btn-sm ms-2" type="button" onClick={handleRemove}>Odstranit</button>
                        )}
                    </SimpleCardCapsule>
                )}
            </div>
            <pre>
                {JSON.stringify(value, null, 2)}
            </pre>
            <hr />
        </div>
    );
}

// Example usage:
// <${exportComponentName} value={where} onChange={setWhere} />
`;
}

// ------------------------- Main ---------------------------
if (require.main === module) {
    const [, , sdlPath, entityType, outputFile] = process.argv;
    if (!sdlPath || !entityType || !outputFile) {
        console.error("Usage: node generate-hasura-filter-form.js <debug-sdl.json> <EntityType> <OutputFile>");
        process.exit(1);
    }
    const ast = JSON.parse(fs.readFileSync(path.resolve(sdlPath), "utf8"));
    // Zjisti input filter typ pro entityType
    const filterType = findFilterType(ast, entityType);
    const fieldTypes = getScalarFieldTypes(ast, filterType);
    const scalarFields = getScalarFieldNames(fieldTypes);
    const filterOperatorsByType = generateFilterOperatorsByType(ast, fieldTypes);
    const exportComponentName = filterType.replace(/Input$/, "InputFilterForm");
    // Vygeneruj komponentu
    const componentCode = generateFilterFormComponent(filterType, fieldTypes, scalarFields, filterOperatorsByType, exportComponentName);
    fs.writeFileSync(outputFile, componentCode, "utf8");
    console.log("✅ Filter component saved to", outputFile);
}