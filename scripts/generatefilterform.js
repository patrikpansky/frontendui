#!/usr/bin/env node
const fs = require("fs");
const path = require("path");

/**
 * Vrátí mapu {fieldName: scalarType} pro input typ (např. AdmissionInputFilter).
 * Nevrací _and/_or ani relation filtry.
 */
function getScalarFieldTypes(ast, inputTypeName) {
    const inputType = (ast.definitions || []).find(
        d => d.kind === "InputObjectTypeDefinition" && d.name.value === inputTypeName
    );
    if (!inputType) throw new Error(`Input type ${inputTypeName} not found`);
    const fieldTypes = {};
    for (const f of inputType.fields) {
        if (!f.name.value.startsWith("_") && f.type.kind === "NamedType") {
            fieldTypes[f.name.value] = f.type.name.value;
        }
    }
    return fieldTypes;
}

function getScalarFieldNames(fieldTypes) {
    return Object.keys(fieldTypes);
}

/**
 * Vrací input typ filtru pro dotaz vracející List[Object!]! daného typu.
 * 
 * @param {object} ast  AST dokument (SDL)
 * @param {string} objectTypeName  Název objektu (např. "AdmissionGQLModel")
 * @returns {string} Název input filtru (např. "AdmissionInputFilter")
 */
function findFilterType(ast, objectTypeName) {
    // Najdi Query typ
    const queryDef = (ast.definitions || []).find(
        d => d.kind === "ObjectTypeDefinition" && d.name.value === "Query"
    );
    if (!queryDef) throw new Error("No Query type found in SDL!");

    // Najdi field v Query, který vrací List[objectTypeName!]
    const listField = (queryDef.fields || []).find(field => {
        // Unwrap do ListType (musí být přímo nebo pod NonNullType)
        let t = field.type;
        while (t.kind === "NonNullType") t = t.type;
        if (t.kind !== "ListType") return false; // musí to být ListType
        // ListType -> type je NonNullType, uvnitř NamedType
        let listOf = t.type;
        while (listOf.kind === "NonNullType") listOf = listOf.type;
        // Musí být NamedType a mít správné jméno
        return listOf.kind === "NamedType" && listOf.name.value === objectTypeName;
    });
    if (!listField) throw new Error(`No Query field found returning List[${objectTypeName}!]!`);

    // Najdi argument where (input type)
    const whereArg = (listField.arguments || []).find(
        arg =>
            arg.name.value === "where" &&
            (arg.type.kind === "NamedType" || arg.type.type?.kind === "NamedType")
    );
    if (!whereArg) throw new Error(`Query field ${listField.name.value} has no "where" argument`);
    return whereArg.type.kind === "NamedType"
        ? whereArg.type.name.value
        : whereArg.type.type.name.value;
}

/**
 * Vytvoří React komponentu filtru pro zadaný input filter type.
 */
function generateFilterFormComponent(inputTypeName, fieldTypes, scalarFields, exportComponentName) {
    // Build fieldTypes map string
    const fieldTypesStr = JSON.stringify(fieldTypes, null, 4);

    // Build scalar field array
    const scalarArrStr = JSON.stringify(scalarFields);

    // Komponenta
    return `/**
 * Generated filter form for ${inputTypeName}, Bootstrap styl, single field selection, logická pole.
 * Generated by generate-hasura-filter-form.js
 */
import { SimpleCardCapsule } from "@hrbolek/uoisfrontend-shared";
import React from "react";
import { Col, Row } from "react-bootstrap";

const logicalFields = ['_and', '_or'];
const fieldTypes = ${fieldTypesStr};

function getHtmlInputType(scalarType) {
    switch (scalarType) {
        case "String": return "text";
        case "Int": case "BigInt": return "number";
        case "Float": case "Decimal": return "number";
        case "Boolean": return "checkbox";
        case "Date": return "date";
        case "Time": return "time";
        case "DateTime": case "Timestamp": return "datetime-local";
        default: return "text";
    }
}
function getFieldScalarType(fieldName) {
    return fieldTypes[fieldName] || "String";
}

/**
 * @param {object} props
 * @param {object} props.value  Aktuální hodnota filtru (where objekt)
 * @param {function} props.onChange  Callback onChange(newValue)
 * @param {string|null} [props.parentLogical]  Parent logical (pokud je uvnitř _and/_or)
 */
export function ${exportComponentName}({ value = {}, onChange, parentLogical = null }) {
    const activeLogical = Object.keys(value).find(k => logicalFields.includes(k));
    const isLogic = !!activeLogical;
    const scalars = ${scalarArrStr};
    const logical = logicalFields.filter(x => x !== parentLogical);
    const selectedField = !isLogic ? Object.keys(value).find(k => !k.startsWith("_")) || "" : "";
    const [operand, setOperand] = React.useState(selectedField ? value[selectedField] : "");

    React.useEffect(() => {
        if (selectedField && value[selectedField] !== operand) setOperand(value[selectedField]);
    }, [value, selectedField]);

    function handleFieldChange(e) {
        const f = e.target.value;
        setOperand(""); // Resetovat operand
        onChange({ [f]: "" });
    }
    function handleOperandChange(e) {
        let val = e.target.value;
        if (e.target.type === "checkbox") val = e.target.checked;
        setOperand(val);
        onChange({ [selectedField]: val });
    }
    function handleAddLogical(logicKey) {
        onChange({ [logicKey]: [{}] });
    }
    function handleLogicChange(idx, v) {
        const arr = [...(value[activeLogical] || [])];
        arr[idx] = v;
        onChange({ [activeLogical]: arr });
    }
    return (
        <div>
            <div className="mb-3 d-flex gap-2">
                {!isLogic && logical.length > 0 && (  
                    <div className="mb-3 d-flex gap-2">
                        {logical.map(f => (
                            <button key={f} type="button"
                                className="btn btn-outline-primary form-control"
                                onClick={() => handleAddLogical(f)}
                            >{f.toUpperCase()}</button>
                        ))}
                    </div>
                )}
                {!isLogic && !selectedField && (
                    <SimpleCardCapsule title={"Operátor/field"}>
                        <select className="form-select" value={selectedField} onChange={handleFieldChange}>
                            <option value="">Vyber operátor…</option>
                            {scalars.map(f => <option key={f} value={f}>{f}</option>)}
                        </select>
                    </SimpleCardCapsule>
                )}
                {!isLogic && selectedField && (() => {
                    const scalarType = getFieldScalarType(selectedField);
                    const inputType = getHtmlInputType(scalarType);
                    return (
                        <SimpleCardCapsule title={selectedField.toUpperCase()}>
                            <Row>
                                <Col>
                                    <select className="form-select" value={selectedField} onChange={handleFieldChange}>
                                        <option value="">Vyber operátor…</option>
                                        {scalars.map(f => <option key={f} value={f}>{f}</option>)}
                                    </select>
                                </Col>
                                <Col>
                                    <input
                                        className="form-control"
                                        type={inputType}
                                        value={inputType === "checkbox" ? undefined : operand}
                                        checked={inputType === "checkbox" ? operand || false : undefined}
                                        onChange={handleOperandChange}
                                        placeholder={"Zadej hodnotu"}
                                    />
                                </Col>
                            </Row>
                        </SimpleCardCapsule>
                    );
                })()}
                {isLogic && (
                    <SimpleCardCapsule title={activeLogical.toUpperCase()}>
                        {(value[activeLogical] || []).map((item, idx) => (
                            <${exportComponentName}
                                key={idx}
                                value={item}
                                onChange={v => handleLogicChange(idx, v)}
                                parentLogical={activeLogical}
                            />
                        ))}
                        <button
                            className="btn btn-outline-primary btn-sm mt-1"
                            type="button"
                            onClick={() => onChange({ ...value, [activeLogical]: [...(value[activeLogical] || []), {}] })}
                        >
                            Přidat podmínku
                        </button>
                    </SimpleCardCapsule>
                )}
            </div>
            <pre>
                {JSON.stringify(value, null, 2)}
            </pre>
            <hr />
        </div>
    );
}

// Example usage:
// <${exportComponentName} value={where} onChange={setWhere} />
`;
}

// ------------------------- Main ---------------------------
if (require.main === module) {
    const [, , sdlPath, entityType, outputFile] = process.argv;
    if (!sdlPath || !entityType || !outputFile) {
        console.error("Usage: node generate-hasura-filter-form.js <debug-sdl.json> <EntityType> <OutputFile>");
        process.exit(1);
    }
    const ast = JSON.parse(fs.readFileSync(path.resolve(sdlPath), "utf8"));
    // Zjisti input filter typ pro entityType
    const filterType = findFilterType(ast, entityType);
    const fieldTypes = getScalarFieldTypes(ast, filterType);
    const scalarFields = getScalarFieldNames(fieldTypes);
    // Komponenta pojmenování
    const exportComponentName = filterType.replace(/Input$/, "InputFilterForm");
    // Vygeneruj komponentu
    const componentCode = generateFilterFormComponent(filterType, fieldTypes, scalarFields, exportComponentName);
    // Zapiš do souboru
    fs.writeFileSync(outputFile, componentCode, "utf8");
    console.log("✅ Filter component saved to", outputFile);
}
