#!/usr/bin/env node
const fs = require("fs");
const path = require("path");

// Helper: Vrátí základní typ (bez NonNull/List)
function getNamedType(type) {
    while (type.kind === "NonNullType" || type.kind === "ListType") {
        type = type.type;
    }
    return type;
}

// Helper: Zjistí, zda pole je [TargetType!]!
function isListOfTargetType(type, typeName) {
    let t = type;
    if (t.kind === "NonNullType") t = t.type;
    if (t.kind !== "ListType") return false;
    t = t.type;
    if (t.kind === "NonNullType") t = t.type;
    return t.kind === "NamedType" && t.name.value === typeName;
}

// Helper: detekce základního typu
function getInputFieldScalarType(field, defsByName) {
    const baseType = getNamedType(field.type);
    if (baseType.kind !== "NamedType") return "String";
    // Najdi scalar/enum
    const t = defsByName[baseType.name.value];
    if (!t) return baseType.name.value;
    if (["ScalarTypeDefinition", "EnumTypeDefinition"].includes(t.kind)) return baseType.name.value;
    return "String"; // fallback (input object)
}

// Vygeneruje mapping name:scalarType z input objektu
function buildFieldTypes(inputDef, defsByName) {
    const result = {};
    for (const field of inputDef.fields || []) {
        // logické jsou _and/_or, ty přeskočíme (nejsou v mappingu)
        if (field.name.value.startsWith("_")) continue;
        result[field.name.value] = getInputFieldScalarType(field, defsByName);
    }
    return result;
}

function getHtmlInputType(scalarType) {
    switch (scalarType) {
        case "String": return "text";
        case "Int": case "BigInt": return "number";
        case "Float": case "Decimal": return "number";
        case "Boolean": return "checkbox";
        case "Date": return "date";
        case "Time": return "time";
        case "DateTime": case "Timestamp": return "datetime-local";
        default: return "text";
    }
}

// Hlavní funkce – vygeneruje zdroják komponenty
function generateFilterComponent(typeName, ast) {
    const defsByName = {};
    for (const def of ast.definitions) {
        if (def.name && def.name.value) defsByName[def.name.value] = def;
    }

    // 1) Najdi Query, která vrací [typeName]
    const Query = defsByName.Query;
    if (!Query) throw new Error("SDL AST neobsahuje Query typ");

    let queryField = null, whereArg = null;
    for (const f of Query.fields) {
        if (isListOfTargetType(f.type, typeName)) {
            queryField = f;
            // Najdi parametr where
            whereArg = (f.arguments || []).find(arg => arg.name.value === "where");
            break;
        }
    }
    if (!queryField || !whereArg) {
        throw new Error("Nebylo možné najít query, která vrací List[" + typeName + "] a má parametr where.");
    }

    // 2) Najdi input typ parametru where
    const whereInputTypeName = getNamedType(whereArg.type).name.value;
    const whereInputDef = defsByName[whereInputTypeName];
    if (!whereInputDef || whereInputDef.kind !== "InputObjectTypeDefinition") {
        throw new Error("Typ where parametru není InputObjectTypeDefinition.");
    }

    // 3) Vygeneruj fieldTypes mapping
    const fieldTypesObj = buildFieldTypes(whereInputDef, defsByName);
    const fieldTypesJs = JSON.stringify(fieldTypesObj, null, 4);

    // 4) Vygeneruj pole všech scalar fieldů (pro výběr fieldu)
    const scalarFieldKeys = Object.keys(fieldTypesObj).map(f => `"${f}"`).join(", ");

    // 5) Název komponenty
    const compName = typeName.replace(/GQLModel$/, "") + "InputFilterForm";

    // 6) Vlastní komponenta (šablona s logikou jak bylo výše, viz předchozí odpověď)
    return `/**
 * Generated filter form for ${whereInputTypeName} (for type ${typeName}), Bootstrap styl, single field selection, logická pole.
 * Generated by generate-hasura-filter-form.js
 */
import React from "react";

const logicalFields = ['_and', '_or'];
const fieldTypes = ${fieldTypesJs};

function getHtmlInputType(scalarType) {
    switch (scalarType) {
        case "String": return "text";
        case "Int": case "BigInt": return "number";
        case "Float": case "Decimal": return "number";
        case "Boolean": return "checkbox";
        case "Date": return "date";
        case "Time": return "time";
        case "DateTime": case "Timestamp": return "datetime-local";
        default: return "text";
    }
}
function getFieldScalarType(fieldName) {
    return fieldTypes[fieldName] || "String";
}

/**
 * @param {object} props
 * @param {object} props.value  Aktuální hodnota filtru (where objekt)
 * @param {function} props.onChange  Callback onChange(newValue)
 * @param {string|null} [props.parentLogical]  Parent logical (pokud je uvnitř _and/_or)
 */
export function ${compName}({ value = {}, onChange, parentLogical = null }) {
    const activeLogical = Object.keys(value).find(k => logicalFields.includes(k));
    const isLogic = !!activeLogical;
    const scalars = [${scalarFieldKeys}];
    const logical = logicalFields.filter(x => x !== parentLogical);
    const selectedField = !isLogic ? Object.keys(value).find(k => !k.startsWith("_")) || "" : "";
    const [operand, setOperand] = React.useState(selectedField ? value[selectedField] : "");

    React.useEffect(() => {
        if (selectedField && value[selectedField] !== operand) setOperand(value[selectedField]);
    }, [value, selectedField]);

    function handleFieldChange(e) {
        const f = e.target.value;
        setOperand(""); // Resetovat operand
        onChange({ [f]: "" });
    }
    function handleOperandChange(e) {
        let val = e.target.value;
        if (e.target.type === "checkbox") val = e.target.checked;
        setOperand(val);
        onChange({ [selectedField]: val });
    }
    function handleAddLogical(logicKey) {
        onChange({ [logicKey]: [{}] });
    }
    function handleLogicChange(idx, v) {
        const arr = [...(value[activeLogical] || [])];
        arr[idx] = v;
        onChange({ [activeLogical]: arr });
    }
    return (
        <div className="border p-3 mb-3">
            {!isLogic && logical.length > 0 && (
                <div className="mb-3 d-flex gap-2">
                    {logical.map(f => (
                        <button key={f} type="button"
                            className="btn btn-outline-primary"
                            onClick={() => handleAddLogical(f)}
                        >{f.toUpperCase()}</button>
                    ))}
                </div>
            )}
            {!isLogic && (
                <div className="mb-3">
                    <label className="form-label">Operátor/field</label>
                    <select className="form-select" value={selectedField} onChange={handleFieldChange}>
                        <option value="">Vyber operátor…</option>
                        {scalars.map(f => <option key={f} value={f}>{f}</option>)}
                    </select>
                </div>
            )}
            {!isLogic && selectedField && (() => {
                const scalarType = getFieldScalarType(selectedField);
                const inputType = getHtmlInputType(scalarType);
                return (
                    <div className="mb-3">
                        <input
                            className="form-control"
                            type={inputType}
                            value={inputType === "checkbox" ? undefined : operand}
                            checked={inputType === "checkbox" ? operand || false : undefined}
                            onChange={handleOperandChange}
                            placeholder={"Zadej hodnotu"}
                        />
                    </div>
                );
            })()}
            {isLogic && (
                <div className="mb-3">
                    <label>{activeLogical.toUpperCase()}</label>
                    {(value[activeLogical] || []).map((item, idx) => (
                        <${compName}
                            key={idx}
                            value={item}
                            onChange={v => handleLogicChange(idx, v)}
                            parentLogical={activeLogical}
                        />
                    ))}
                    <button
                        className="btn btn-outline-primary btn-sm mt-1"
                        type="button"
                        onClick={() => onChange({ ...value, [activeLogical]: [...(value[activeLogical] || []), {}] })}
                    >
                        Přidat podmínku
                    </button>
                </div>
            )}
        </div>
    );
}

// Example usage:
// <${compName} value={where} onChange={setWhere} />

`;

}

// CLI použití: node generate-hasura-filter-form.js debug-sdl.json AdmissionGQLModel > AdmissionInputFilterForm.jsx
if (require.main === module) {
    const [, , sdlPath, typeName, outputPath] = process.argv;
    if (!sdlPath || !typeName || !outputPath) {
        console.error(`Usage: node generate-hasura-filter-form.js <debug-sdl.json> <TargetTypeName> <output.jsx>`);
        process.exit(1);
    }
    const ast = JSON.parse(fs.readFileSync(path.resolve(sdlPath), "utf8"));
    const output = generateFilterComponent(typeName, ast);
    
    fs.writeFileSync(path.resolve(outputPath), output, "utf8");
    console.log(`✅ File written: ${outputPath}`);
}

module.exports = { generateFilterComponent };
